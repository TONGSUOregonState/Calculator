<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>可视化拖拽计算 Demo（Drawflow + Chart.js）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Drawflow 样式 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/drawflow@0.0.54/dist/drawflow.min.css">

  <!-- 简单页面样式 -->
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f4f6;
      color: #111827;
    }
    h1 {
      font-size: 1.2rem;
      margin: 0;
    }
    .layout {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(300px, 1fr);
      height: 100vh;
    }
    #drawflow-wrapper {
      position: relative;
      background: #111827;
    }
    #drawflow {
      width: 100%;
      height: 100%;
    }
    .sidebar {
      padding: 1rem 1.25rem;
      background: #ffffff;
      border-left: 1px solid #e5e7eb;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .btn {
      padding: 0.4rem 0.75rem;
      border-radius: 999px;
      border: 1px solid #111827;
      background: #111827;
      color: #ffffff;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .btn:hover {
      background: #1f2937;
    }
    #result-box {
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      font-size: 0.9rem;
    }
    #result-value {
      font-weight: 600;
      color: #111827;
    }
    #chart-container {
      flex: 1;
      min-height: 0;
    }
    #chart {
      width: 100%;
      height: 100%;
    }
    .hint {
      font-size: 0.8rem;
      color: #6b7280;
      line-height: 1.4;
    }

    /* 自定义节点内部样式 */
    .node-constant {
      padding: 0.25rem 0.3rem;
      font-size: 0.75rem;
    }
    .node-constant label {
      display: block;
      font-size: 0.7rem;
      margin-bottom: 0.1rem;
      color: #4b5563;
    }
    .node-constant input {
      width: 80px;
      padding: 0.1rem 0.25rem;
      font-size: 0.75rem;
    }
    .node-mul, .node-output {
      padding: 0.35rem 0.4rem;
      font-size: 0.8rem;
      text-align: center;
    }
    .node-output-value {
      margin-top: 0.25rem;
      font-size: 0.8rem;
      color: #16a34a;
      font-weight: 600;
    }

    /* 让节点稍微现代一点 */
    .drawflow-node {
      border-radius: 0.5rem !important;
      border-color: #9ca3af !important;
      box-shadow: 0 8px 16px rgba(0,0,0,0.25);
      background: #f9fafb !important;
    }
    .drawflow-node.selected {
      border-color: #2563eb !important;
    }
  </style>
</head>
<body>
  <div class="layout">
    <!-- 左侧：Drawflow 画布 -->
    <div id="drawflow-wrapper">
      <div id="drawflow"></div>
    </div>

    <!-- 右侧：结果 + 按钮 + 图表 -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <h1>拖拽计算 Demo</h1>
        <button id="run-btn" class="btn">运行计算并画图</button>
      </div>

      <div id="result-box">
        当前输出值：<span id="result-value">（尚未计算）</span>
      </div>

      <div id="chart-container">
        <canvas id="chart"></canvas>
      </div>

      <p class="hint">
        使用说明：<br>
        · 左边有两个"常数"节点和一个"乘法"节点、一个"输出"节点。<br>
        · 修改常数里的数值，或者拖动连线改变输入。<br>
        · 点击「运行计算并画图」，程序会：<br>
        &nbsp;&nbsp;1）按连线顺序，从常数 → 乘法 → 输出，求出最终输出值 k；<br>
        &nbsp;&nbsp;2）在右侧画出 y = k · t （0 ≤ t ≤ 10） 的折线图。<br>
        这只是一个最小 demo，后面可以一起扩展成更复杂的物理/信号系统编辑器。
      </p>
    </aside>
  </div>

  <!-- Drawflow 与 Chart.js 脚本 -->
  <script src="https://cdn.jsdelivr.net/npm/drawflow@0.0.54/dist/drawflow.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script>
    // 初始化 Drawflow
    const container = document.getElementById('drawflow');
    const editor = new Drawflow(container);
    editor.start();

    // 在画布中居中一点
    editor.zoom_value = 0.8;
    editor.precanvas.style.transform = "translate(200px, 80px) scale(0.8)";

    // 辅助：为常数节点绑定 input -> data.value
    function bindConstantInput(nodeId) {
      const inputEl = document.querySelector('#node-' + nodeId + ' input');
      if (!inputEl) return;
      inputEl.addEventListener('input', () => {
        const node = editor.getNodeFromId(nodeId);
        const v = parseFloat(inputEl.value);
        node.data.value = isNaN(v) ? 0 : v;
      });
    }

    // 创建常数节点
    function addConstantNode(value, x, y) {
      const html = `
        <div class="node-constant">
          <label>常数</label>
          <input type="number" value="${value}">
        </div>
      `;
      const id = editor.addNode(
        'constant',   // name
        0,            // inputs
        1,            // outputs
        x, y,
        'constant',   // class
        { value: value },
        html
      );
      bindConstantInput(id);
      return id;
    }

    // 创建乘法节点：将其所有输入相乘
    function addMultiplyNode(x, y) {
      const html = `<div class="node-mul"><strong>乘法：所有输入相乘</strong></div>`;
      const id = editor.addNode(
        'multiply',
        2,   // 有两个输入端口 input_1, input_2
        1,   // 一个输出端口 output_1
        x, y,
        'multiply',
        {},
        html
      );
      return id;
    }

    // 创建输出节点：展示最终数值
    function addOutputNode(x, y) {
      const html = `
        <div class="node-output">
          <div><strong>输出节点</strong></div>
          <div class="node-output-value" data-output-value>k = ?</div>
        </div>
      `;
      const id = editor.addNode(
        'output',
        1,   // 一个输入
        0,   // 无输出
        x, y,
        'output',
        {},
        html
      );
      return id;
    }

    // 预先布置几个节点
    const idConst1 = addConstantNode(2, 50, 50);
    const idConst2 = addConstantNode(3, 50, 220);
    const idMul    = addMultiplyNode(350, 140);
    const idOut    = addOutputNode(600, 140);

    // 连线：const1 -> mul, const2 -> mul, mul -> out
    editor.addConnection(idConst1, 'output_1', idMul, 'input_1');
    editor.addConnection(idConst2, 'output_1', idMul, 'input_2');
    editor.addConnection(idMul, 'output_1', idOut, 'input_1');

    // 图计算：递归求值
    function evaluateNode(id, nodes, cache) {
      if (cache[id] !== undefined) return cache[id];

      const node = nodes[id];
      let value = 0;

      if (node.name === 'constant') {
        value = parseFloat(node.data.value);
        if (isNaN(value)) value = 0;
      } else {
        // 收集该节点所有输入端口的上游节点值
        const inputs = node.inputs || {};
        const inputValues = [];

        for (const portName of Object.keys(inputs)) {
          const port = inputs[portName];
          (port.connections || []).forEach(conn => {
            const fromId = conn.node;       // 上游节点 ID（字符串）
            const v = evaluateNode(fromId, nodes, cache);
            inputValues.push(v);
          });
        }

        if (node.name === 'multiply') {
          // 所有输入相乘，若没有输入则为 0
          if (inputValues.length === 0) {
            value = 0;
          } else {
            value = inputValues.reduce((acc, v) => acc * v, 1);
          }
        } else if (node.name === 'output') {
          // 输出节点：直接把第一个输入的值作为输出
          value = inputValues.length > 0 ? inputValues[0] : 0;
        } else {
          // 未定义类型：简单地把第一个输入传递下去
          value = inputValues.length > 0 ? inputValues[0] : 0;
        }
      }

      cache[id] = value;
      return value;
    }

    // 运行整张图：找到 output 节点并求值
    function runGraphAndGetOutput() {
      const exported = editor.export();
      const nodes = exported.drawflow.Home.data;
      let outputId = null;

      for (const id of Object.keys(nodes)) {
        if (nodes[id].name === 'output') {
          outputId = id;
          break;
        }
      }
      if (!outputId) return 0;

      const cache = {};
      const result = evaluateNode(outputId, nodes, cache);

      // 更新输出节点中的显示文字
      const outNodeDom = document.querySelector('#node-' + outputId + ' [data-output-value]');
      if (outNodeDom) {
        outNodeDom.textContent = 'k = ' + result.toFixed(4);
      }
      return result;
    }

    // Chart.js：画 y = k * t
    let chartInstance = null;
    function plotLine(k) {
      const ctx = document.getElementById('chart').getContext('2d');
      const t = [];
      const y = [];
      const maxT = 10;
      const step = 0.1;
      for (let x = 0; x <= maxT + 1e-9; x += step) {
        t.push(parseFloat(x.toFixed(2)));
        y.push(k * x);
      }

      if (chartInstance) {
        chartInstance.destroy();
      }

      chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: t,
          datasets: [{
            label: 'y = k · t',
            data: y,
            pointRadius: 0,
            borderWidth: 2,
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { title: { display: true, text: 't' } },
            y: { title: { display: true, text: 'y' } }
          }
        }
      });
    }

    // 点击按钮：运行 + 画图
    const runBtn = document.getElementById('run-btn');
    const resultSpan = document.getElementById('result-value');

    runBtn.addEventListener('click', () => {
      const k = runGraphAndGetOutput();
      resultSpan.textContent = k.toFixed(4);
      plotLine(k);
    });

    // 首次自动跑一遍
    window.addEventListener('load', () => {
      const k = runGraphAndGetOutput();
      resultSpan.textContent = k.toFixed(4);
      plotLine(k);
    });
  </script>
</body>
</html>
